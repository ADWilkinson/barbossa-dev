#!/usr/bin/env python3
"""
Barbossa CLI - Simple interface for managing your autonomous dev team.

Commands:
    barbossa init              Interactive setup wizard
    barbossa health            Check system health
    barbossa doctor            Comprehensive diagnostics
    barbossa run <agent>       Run an agent manually
    barbossa status            Show current status
    barbossa logs [agent]      View agent logs
    barbossa watch             Tail all agent logs in real-time
    barbossa metrics           View execution metrics

Shortcuts:
    barbossa engineer          Same as: barbossa run engineer
    barbossa tl                Same as: barbossa run tech-lead
    barbossa disco             Same as: barbossa run discovery
"""

import argparse
import json
import os
import subprocess
import sys
import time
import threading
from pathlib import Path
from datetime import datetime


# Colors for terminal output
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    DIM = '\033[2m'
    BOLD = '\033[1m'
    END = '\033[0m'


def ok(msg): print(f"{Colors.GREEN}✓{Colors.END} {msg}")
def warn(msg): print(f"{Colors.YELLOW}⚠{Colors.END} {msg}")
def err(msg): print(f"{Colors.RED}✗{Colors.END} {msg}")
def info(msg): print(f"{Colors.BLUE}→{Colors.END} {msg}")
def dim(msg): print(f"{Colors.DIM}{msg}{Colors.END}")
def header(msg): print(f"\n{Colors.BOLD}{msg}{Colors.END}")


def get_app_dir():
    """Get the Barbossa application directory."""
    env_dir = os.environ.get('BARBOSSA_DIR')
    if env_dir:
        return Path(env_dir)

    # Check if running in Docker
    if Path('/app').exists() and Path('/app/src/barbossa').exists():
        return Path('/app')

    # Running locally - go up 3 levels from src/barbossa/cli/
    return Path(__file__).parent.parent.parent.parent


def run_cmd(cmd, capture=True, timeout=30):
    """Run a shell command."""
    try:
        result = subprocess.run(
            cmd, shell=True, capture_output=capture,
            text=True, timeout=timeout
        )
        return result.returncode == 0, result.stdout.strip() if capture else "", result.stderr.strip() if capture else ""
    except subprocess.TimeoutExpired:
        return False, "", "Command timed out"
    except Exception as e:
        return False, "", str(e)


# =============================================================================
# HEALTH CHECK
# =============================================================================

def check_config(app_dir):
    """Check if config file exists and is valid."""
    config_file = app_dir / 'config' / 'repositories.json'

    if not config_file.exists():
        return False, "Config file not found", f"Run: cp config/repositories.json.example config/repositories.json"

    try:
        with open(config_file) as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        return False, f"Invalid JSON in config: {e}", "Fix the JSON syntax error"

    # Check required fields
    if not config.get('owner'):
        return False, "Missing 'owner' in config", "Add your GitHub username as 'owner'"

    repos = config.get('repositories', [])
    if not repos:
        return False, "No repositories configured", "Add at least one repository to 'repositories'"

    for i, repo in enumerate(repos):
        if not repo.get('name'):
            return False, f"Repository {i+1} missing 'name'", "Add 'name' to each repository"
        if not repo.get('url'):
            return False, f"Repository '{repo.get('name', i+1)}' missing 'url'", "Add 'url' to each repository"

    return True, f"Config valid ({len(repos)} repositories)", None


def check_github_cli():
    """Check GitHub CLI authentication."""
    success, stdout, stderr = run_cmd("gh auth status")
    if success:
        return True, "GitHub CLI authenticated", None
    return False, "GitHub CLI not authenticated", "Run: gh auth login"


def check_claude_cli():
    """Check Claude CLI authentication via environment variables."""
    # Check for either CLAUDE_CODE_OAUTH_TOKEN (from claude setup-token) or ANTHROPIC_API_KEY
    oauth_token = os.environ.get('CLAUDE_CODE_OAUTH_TOKEN')
    api_key = os.environ.get('ANTHROPIC_API_KEY')

    if not oauth_token and not api_key:
        return False, "Claude authentication not set", "Set CLAUDE_CODE_OAUTH_TOKEN or ANTHROPIC_API_KEY in .env"

    # Determine which auth method is being used
    if oauth_token:
        # OAuth token from claude setup-token (sk-ant-oat01-...)
        return True, "Claude authenticated via OAuth token", None
    elif api_key:
        # API key from console.anthropic.com (sk-ant-api03-...)
        return True, "Claude authenticated via API key", None

    return False, "Claude authentication not set", "Set CLAUDE_CODE_OAUTH_TOKEN or ANTHROPIC_API_KEY in .env"


def check_ssh_keys():
    """Check SSH keys for GitHub access."""
    ssh_dir = Path.home() / '.ssh'

    if not ssh_dir.exists():
        return False, "No SSH directory found", "Set up SSH keys for GitHub"

    key_files = list(ssh_dir.glob('id_*'))
    key_files = [f for f in key_files if not f.suffix == '.pub']

    if not key_files:
        return False, "No SSH keys found", "Generate SSH keys: ssh-keygen -t ed25519"

    # Test GitHub SSH access
    success, stdout, stderr = run_cmd("ssh -T git@github.com 2>&1", timeout=10)
    if "successfully authenticated" in stderr.lower() or "successfully authenticated" in stdout.lower():
        return True, "SSH keys configured for GitHub", None
    elif "permission denied" in stderr.lower():
        return False, "SSH key not added to GitHub", "Add your SSH key to GitHub"

    return True, f"SSH keys found ({len(key_files)} keys)", None


def check_git_config():
    """Check git configuration."""
    success, name, _ = run_cmd("git config --global user.name")
    if not success or not name:
        return False, "Git user.name not set", "Run: git config --global user.name 'Your Name'"

    success, email, _ = run_cmd("git config --global user.email")
    if not success or not email:
        return False, "Git user.email not set", "Run: git config --global user.email 'you@example.com'"

    return True, f"Git configured as {name} <{email}>", None


def check_docker():
    """Check if running in Docker or Docker is available."""
    if Path('/.dockerenv').exists():
        return True, "Running inside Docker", None

    success, stdout, _ = run_cmd("docker --version")
    if success:
        return True, "Docker available", None

    return False, "Docker not installed", "Install Docker: https://docs.docker.com/get-docker/"


def cmd_health(args):
    """Run health checks."""
    app_dir = get_app_dir()

    header("Barbossa Health Check")
    print()

    checks = [
        ("Config", lambda: check_config(app_dir)),
        ("GitHub CLI", check_github_cli),
        ("Claude CLI", check_claude_cli),
        ("SSH Keys", check_ssh_keys),
        ("Git Config", check_git_config),
        ("Docker", check_docker),
    ]

    all_ok = True
    fixes_needed = []

    for name, check_fn in checks:
        try:
            success, message, fix = check_fn()
            if success:
                ok(f"{name}: {message}")
            else:
                err(f"{name}: {message}")
                if fix:
                    fixes_needed.append(f"  {name}: {fix}")
                all_ok = False
        except Exception as e:
            err(f"{name}: Error - {e}")
            all_ok = False

    print()

    if all_ok:
        ok("All checks passed! Barbossa is ready to run.")
    else:
        warn("Some checks failed. Fixes needed:")
        for fix in fixes_needed:
            print(fix)

    return 0 if all_ok else 1


# =============================================================================
# INIT WIZARD
# =============================================================================

def cmd_init(args):
    """Interactive setup wizard."""
    app_dir = get_app_dir()
    config_file = app_dir / 'config' / 'repositories.json'

    header("Barbossa Setup Wizard")
    print()
    print("This wizard will help you configure Barbossa.")
    print("Press Ctrl+C at any time to cancel.")
    print()

    try:
        # Step 1: GitHub username
        header("Step 1: GitHub Username")
        owner = input("Enter your GitHub username: ").strip()
        if not owner:
            err("GitHub username is required")
            return 1
        ok(f"Owner: {owner}")

        # Step 2: Repository
        header("Step 2: Repository")
        print("Enter details for your repository (you can add more later)")
        print()

        repo_name = input("Repository name (e.g., my-app): ").strip()
        if not repo_name:
            err("Repository name is required")
            return 1

        # Suggest URL based on owner/name
        default_url = f"git@github.com:{owner}/{repo_name}.git"
        repo_url = input(f"Repository URL [{default_url}]: ").strip() or default_url

        ok(f"Repository: {repo_name}")
        ok(f"URL: {repo_url}")

        # Step 3: Optional - package manager
        header("Step 3: Package Manager (optional)")
        print("What package manager does your project use?")
        print("  1. npm (default)")
        print("  2. pnpm")
        print("  3. yarn")
        print("  4. bun")

        pm_choice = input("Enter choice [1]: ").strip() or "1"
        pm_map = {"1": "npm", "2": "pnpm", "3": "yarn", "4": "bun"}
        package_manager = pm_map.get(pm_choice, "npm")
        ok(f"Package manager: {package_manager}")

        # Step 4: Files to protect
        header("Step 4: Protected Files (optional)")
        print("Enter files/directories Barbossa should never modify.")
        print("Press Enter when done. Leave empty to skip.")

        do_not_touch = []
        while True:
            path = input("  Protected path: ").strip()
            if not path:
                break
            do_not_touch.append(path)

        if do_not_touch:
            ok(f"Protected: {len(do_not_touch)} paths")

        # Build config
        config = {
            "owner": owner,
            "repositories": [
                {
                    "name": repo_name,
                    "url": repo_url,
                    "package_manager": package_manager,
                }
            ]
        }

        if do_not_touch:
            config["repositories"][0]["do_not_touch"] = do_not_touch

        # Ensure config directory exists
        config_file.parent.mkdir(parents=True, exist_ok=True)

        # Write config
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)

        header("Setup Complete!")
        print()
        ok(f"Config saved to: {config_file}")
        print()
        info("Next steps:")
        print("  1. Run health check:  barbossa health")
        print("  2. Start Barbossa:    docker compose up -d")
        print("  3. Watch logs:        docker compose logs -f")
        print()
        print("Your first PR should appear within 2 hours!")

        return 0

    except KeyboardInterrupt:
        print("\n")
        warn("Setup cancelled")
        return 1


# =============================================================================
# AGENT INFO
# =============================================================================

AGENTS = {
    'engineer': {
        'module': 'barbossa.agents.engineer',
        'desc': 'Implements features from backlog issues',
    },
    'tech-lead': {
        'module': 'barbossa.agents.tech_lead',
        'desc': 'Reviews PRs, merges or requests changes',
    },
    'discovery': {
        'module': 'barbossa.agents.discovery',
        'desc': 'Finds TODOs, missing tests, tech debt',
    },
    'product': {
        'module': 'barbossa.agents.product',
        'desc': 'Suggests high-value features',
    },
    'auditor': {
        'module': 'barbossa.agents.auditor',
        'desc': 'Weekly health check and cleanup',
    },
    'spec': {
        'module': 'barbossa.agents.spec_generator',
        'desc': 'Cross-repo feature specs (Spec Mode)',
    },
}

# Shortcuts for common agents
AGENT_ALIASES = {
    'tl': 'tech-lead',
    'disco': 'discovery',
    'prod': 'product',
}


# =============================================================================
# RUN AGENT
# =============================================================================

def cmd_run(args):
    """Run an agent manually."""
    app_dir = get_app_dir()

    if not args.agent:
        header("Available Agents")
        print()
        for name, info in AGENTS.items():
            desc = f"{Colors.DIM}{info['desc']}{Colors.END}"
            if name == 'spec':
                print(f"  {name:12} {desc}")
                print(f"  {'':12} Usage: barbossa run spec [--product NAME]")
            else:
                print(f"  {name:12} {desc}")
        print()
        dim("Shortcuts: engineer, tl, disco, prod")
        return 0

    agent = args.agent.lower()

    # Resolve alias
    agent = AGENT_ALIASES.get(agent, agent)

    if agent not in AGENTS:
        err(f"Unknown agent: {args.agent}")
        print(f"Available: {', '.join(AGENTS.keys())}")
        print(f"Shortcuts: {', '.join(AGENT_ALIASES.keys())}")
        return 1

    module = AGENTS[agent]['module']

    header(f"Running {agent} agent")
    info(AGENTS[agent]['desc'])
    print()

    # Set PYTHONPATH and run the agent as a module
    env = os.environ.copy()
    env['PYTHONPATH'] = str(app_dir / 'src')

    # Build command with extra arguments
    cmd = ['python3', '-m', module]

    # Pass through --product for spec agent
    if agent == 'spec' and hasattr(args, 'product') and args.product:
        cmd.extend(['--product', args.product])

    info(f"Logs: barbossa logs {agent}")
    print()

    os.execvpe('python3', cmd, env)


# =============================================================================
# STATUS
# =============================================================================

def cmd_status(args):
    """Show current status."""
    app_dir = get_app_dir()

    header("Barbossa Status")
    print()

    # Check config
    config_file = app_dir / 'config' / 'repositories.json'
    if config_file.exists():
        try:
            with open(config_file) as f:
                config = json.load(f)
            repos = config.get('repositories', [])
            ok(f"Configured: {len(repos)} repositories")
            for repo in repos:
                print(f"    - {repo.get('name', 'unnamed')}")
        except (json.JSONDecodeError, IOError) as e:
            err(f"Could not read config: {e}")
    else:
        warn("No config file found")

    print()

    # Check for recent sessions
    sessions_file = app_dir / 'sessions.json'
    if sessions_file.exists():
        try:
            with open(sessions_file) as f:
                sessions = json.load(f)

            if sessions:
                info("Recent Sessions:")
                for session in sessions[:5]:
                    status = session.get('status', 'unknown')
                    icon = {'completed': '✓', 'failed': '✗', 'running': '...', 'timeout': '⏱'}.get(status, '?')
                    repo = session.get('repository', 'unknown')
                    started = session.get('started', '')[:16]
                    print(f"    [{icon}] {repo} - {started}")
                    if session.get('pr_url'):
                        print(f"        PR: {session['pr_url']}")
        except (json.JSONDecodeError, IOError):
            pass  # Could not read sessions file

    print()

    # Check cron status (if in Docker)
    success, stdout, _ = run_cmd("crontab -l 2>/dev/null")
    if success and stdout:
        info("Cron schedule active")

    return 0


# =============================================================================
# LOGS
# =============================================================================

def cmd_logs(args):
    """View agent logs."""
    app_dir = get_app_dir()
    logs_dir = app_dir / 'logs'

    if not logs_dir.exists():
        err("No logs directory found")
        return 1

    agent_patterns = {
        'engineer': 'barbossa_*.log',
        'tech-lead': 'tech_lead_*.log',
        'discovery': 'discovery_*.log',
        'product': 'product_*.log',
        'auditor': 'auditor_*.log',
        'spec': 'spec_*.log',
    }

    if args.agent:
        pattern = agent_patterns.get(args.agent.lower())
        if not pattern:
            err(f"Unknown agent: {args.agent}")
            return 1
    else:
        pattern = '*.log'

    # Find most recent log
    logs = sorted(logs_dir.glob(pattern), key=lambda p: p.stat().st_mtime, reverse=True)

    if not logs:
        warn(f"No logs found matching: {pattern}")
        return 1

    latest_log = logs[0]
    info(f"Showing: {latest_log.name}")
    print()

    # Tail the log
    if args.follow:
        os.execvp('tail', ['tail', '-f', str(latest_log)])
    else:
        lines = args.lines or 50
        os.execvp('tail', ['tail', f'-{lines}', str(latest_log)])


# =============================================================================
# DOCTOR (comprehensive diagnostics)
# =============================================================================

def cmd_doctor(args):
    """Comprehensive diagnostics - shareable report of system state."""
    app_dir = get_app_dir()

    header("Barbossa Doctor")
    print("Comprehensive system diagnostics")
    print("=" * 50)

    issues = []
    warnings = []

    # 1. Config check
    print(f"\n{Colors.BOLD}Configuration{Colors.END}")
    config_file = app_dir / 'config' / 'repositories.json'
    if config_file.exists():
        try:
            with open(config_file) as f:
                config = json.load(f)
            repos = config.get('repositories', [])
            ok(f"Config valid: {len(repos)} repo(s)")
            for repo in repos:
                print(f"    - {repo.get('name', 'unnamed')}")
        except json.JSONDecodeError as e:
            err(f"Invalid JSON: {e}")
            issues.append("Fix JSON syntax in config/repositories.json")
    else:
        err("Config file missing")
        issues.append("Run: barbossa init")

    # 2. Auth check
    print(f"\n{Colors.BOLD}Authentication{Colors.END}")

    # GitHub
    success, stdout, _ = run_cmd("gh auth status 2>&1")
    if success:
        ok("GitHub CLI authenticated")
    else:
        err("GitHub CLI not authenticated")
        issues.append("Run: gh auth login")

    # Claude
    oauth = os.environ.get('CLAUDE_CODE_OAUTH_TOKEN')
    api_key = os.environ.get('ANTHROPIC_API_KEY')
    if oauth:
        ok("Claude OAuth token set")
    elif api_key:
        ok("Anthropic API key set")
    else:
        err("No Claude authentication")
        issues.append("Set CLAUDE_CODE_OAUTH_TOKEN or ANTHROPIC_API_KEY in .env")

    # 3. Git config
    print(f"\n{Colors.BOLD}Git Configuration{Colors.END}")
    success, name, _ = run_cmd("git config --global user.name")
    success2, email, _ = run_cmd("git config --global user.email")
    if success and name and success2 and email:
        ok(f"Git: {name} <{email}>")
    else:
        warn("Git user not configured")
        warnings.append("Run: git config --global user.name 'Your Name'")

    # 4. Docker check
    print(f"\n{Colors.BOLD}Environment{Colors.END}")
    if Path('/.dockerenv').exists():
        ok("Running in Docker")
    else:
        success, _, _ = run_cmd("docker --version")
        if success:
            ok("Docker available")
        else:
            warn("Docker not installed")
            warnings.append("Install Docker for production use")

    # 5. Logs check
    print(f"\n{Colors.BOLD}Recent Activity{Colors.END}")
    logs_dir = app_dir / 'logs'
    if logs_dir.exists():
        logs = sorted(logs_dir.glob('*.log'), key=lambda p: p.stat().st_mtime, reverse=True)
        if logs:
            recent = logs[:3]
            for log in recent:
                mtime = datetime.fromtimestamp(log.stat().st_mtime)
                age = datetime.now() - mtime
                if age.days > 0:
                    age_str = f"{age.days}d ago"
                elif age.seconds > 3600:
                    age_str = f"{age.seconds // 3600}h ago"
                else:
                    age_str = f"{age.seconds // 60}m ago"
                print(f"    {log.name} ({age_str})")
        else:
            warn("No logs yet")
    else:
        warn("No logs directory")

    # 6. Cron status
    print(f"\n{Colors.BOLD}Schedule{Colors.END}")
    success, stdout, _ = run_cmd("crontab -l 2>/dev/null")
    if success and stdout:
        lines = [l for l in stdout.split('\n') if l.strip() and not l.startswith('#')]
        ok(f"Cron active: {len(lines)} scheduled jobs")
    else:
        warn("No cron schedule (agents won't run automatically)")
        warnings.append("Start container to enable scheduled runs")

    # Summary
    print("\n" + "=" * 50)
    if issues:
        err(f"{len(issues)} issue(s) found:")
        for issue in issues:
            print(f"    {Colors.RED}→{Colors.END} {issue}")
    if warnings:
        warn(f"{len(warnings)} warning(s):")
        for warning in warnings:
            print(f"    {Colors.YELLOW}→{Colors.END} {warning}")
    if not issues and not warnings:
        ok("All systems healthy!")
        print("\n    Ready to ship code while you sleep.")

    return 1 if issues else 0


# =============================================================================
# WATCH (tail all logs)
# =============================================================================

def cmd_watch(args):
    """Tail all agent logs in real-time."""
    app_dir = get_app_dir()
    logs_dir = app_dir / 'logs'

    if not logs_dir.exists():
        err("No logs directory found")
        info("Logs appear after agents run")
        return 1

    header("Watching all agent logs")
    dim("Press Ctrl+C to stop")
    print()

    # Find all log files
    log_files = list(logs_dir.glob('*.log'))
    if not log_files:
        warn("No log files yet")
        info("Run an agent first: barbossa run engineer")
        return 1

    # Use tail -f on all logs
    cmd = ['tail', '-f'] + [str(f) for f in sorted(log_files)]
    os.execvp('tail', cmd)


# =============================================================================
# METRICS
# =============================================================================

def cmd_metrics(args):
    """View and manage execution metrics."""
    from barbossa.utils.metrics import get_metrics_summary, rotate_metrics
    from barbossa.dashboard.metrics_dashboard import generate_dashboard_html

    header("Barbossa Metrics")

    if args.action == 'summary':
        summary = get_metrics_summary(days=args.days)

        if summary['total_runs'] == 0:
            warn(f"No metrics found for the last {args.days} days")
            info("Metrics are collected automatically when agents run")
            return 0

        print(f"\n{Colors.BOLD}Summary (Last {args.days} days){Colors.END}")
        print("-" * 40)
        print(f"Total Runs:     {summary['total_runs']}")
        print(f"Successful:     {summary['successful_runs']}")
        print(f"Failed:         {summary['failed_runs']}")

        # Color code success rate
        rate = summary['success_rate']
        if rate >= 80:
            color = Colors.GREEN
        elif rate >= 60:
            color = Colors.YELLOW
        else:
            color = Colors.RED
        print(f"Success Rate:   {color}{rate}%{Colors.END}")

        print(f"\nTotal Cost:     ${summary['total_cost_usd']:.2f}")
        print(f"Avg Cost/Run:   ${summary['avg_cost_per_run']:.4f}")
        print(f"Total Tokens:   {summary['total_tokens']:,}")
        print(f"Avg Duration:   {summary['avg_duration_seconds']:.1f}s")

        if summary['by_agent']:
            print(f"\n{Colors.BOLD}By Agent{Colors.END}")
            print("-" * 40)
            for agent, stats in summary['by_agent'].items():
                success_pct = round(stats['successes'] / stats['runs'] * 100) if stats['runs'] > 0 else 0
                print(f"  {agent:12} {stats['runs']:4} runs, {success_pct:3}% success, ${stats['cost_usd']:.2f}")

        if summary['error_breakdown']:
            print(f"\n{Colors.BOLD}Errors{Colors.END}")
            print("-" * 40)
            for error_type, count in summary['error_breakdown'].items():
                print(f"  {error_type}: {count}")

        return 0

    elif args.action == 'dashboard':
        info(f"Generating dashboard for last {args.days} days...")
        output_path = generate_dashboard_html(days=args.days)
        ok(f"Dashboard generated: {output_path}")

        if args.open:
            import webbrowser
            webbrowser.open(f'file://{output_path}')
            info("Opening dashboard in browser...")

        return 0

    elif args.action == 'rotate':
        info("Rotating metrics file (removing entries older than 30 days)...")
        removed = rotate_metrics()
        ok(f"Removed {removed} old entries")
        return 0

    return 0


# =============================================================================
# MAIN
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Barbossa - Your autonomous AI development team',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
  init              Interactive setup wizard
  health            Quick health check
  doctor            Comprehensive diagnostics
  run <agent>       Run an agent manually
  status            Show current status
  logs [agent]      View agent logs
  watch             Tail all logs in real-time
  metrics           View execution metrics

Shortcuts:
  engineer          Same as: run engineer
  tl                Same as: run tech-lead
  disco             Same as: run discovery

Examples:
  barbossa init                 # Set up Barbossa
  barbossa doctor               # Full diagnostics
  barbossa engineer             # Run engineer now
  barbossa watch                # Tail all logs
  barbossa logs tl -f           # Follow tech lead logs
        """
    )

    subparsers = parser.add_subparsers(dest='command')

    # init
    subparsers.add_parser('init', help='Interactive setup wizard').set_defaults(func=cmd_init)

    # health
    subparsers.add_parser('health', help='Quick health check').set_defaults(func=cmd_health)

    # doctor
    subparsers.add_parser('doctor', help='Comprehensive diagnostics').set_defaults(func=cmd_doctor)

    # run
    run_parser = subparsers.add_parser('run', help='Run an agent manually')
    run_parser.add_argument('agent', nargs='?', help='Agent: engineer, tech-lead, discovery, product, auditor, spec')
    run_parser.add_argument('--product', help='For spec agent: only process this product')
    run_parser.set_defaults(func=cmd_run)

    # status
    subparsers.add_parser('status', help='Show current status').set_defaults(func=cmd_status)

    # logs
    logs_parser = subparsers.add_parser('logs', help='View agent logs')
    logs_parser.add_argument('agent', nargs='?', help='Agent logs to view')
    logs_parser.add_argument('-f', '--follow', action='store_true', help='Follow log output')
    logs_parser.add_argument('-n', '--lines', type=int, help='Number of lines to show')
    logs_parser.set_defaults(func=cmd_logs)

    # watch
    subparsers.add_parser('watch', help='Tail all logs in real-time').set_defaults(func=cmd_watch)

    # metrics
    metrics_parser = subparsers.add_parser('metrics', help='View execution metrics')
    metrics_parser.add_argument('action', nargs='?', default='summary',
                                choices=['summary', 'dashboard', 'rotate'],
                                help='Action: summary (default), dashboard, rotate')
    metrics_parser.add_argument('--days', type=int, default=7, help='Number of days to include')
    metrics_parser.add_argument('--open', action='store_true', help='Open dashboard in browser')
    metrics_parser.set_defaults(func=cmd_metrics)

    # Agent aliases as top-level commands
    for alias, agent in [('engineer', 'engineer'), ('tl', 'tech-lead'), ('disco', 'discovery'), ('prod', 'product')]:
        alias_parser = subparsers.add_parser(alias, help=f"Run {agent} agent")
        alias_parser.set_defaults(func=cmd_run, agent=agent)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
